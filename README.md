# TimeSeriesForecasting | Применение методов авторегрессии в задачах прогнозирования временных рядов
Цель данной работы — рассмотреть применение методов авторегрессии в задачах прогнозирования временных рядов и рассмотреть два инструмента для прогнозирования: arima и fbprophet. 
Из поставленной цели вытекают следующие задачи: 
-	рассмотреть особенности задач прогнозирования временных рядов, его цели и задачи; 
-	рассмотреть метод авторегрессии; 
-	описать необходимые формулы и понятия; 
-	рассмотреть модели arima и fbprophet;
### ARIMA
Наиболее распространенной авторегрессионной моделью прогнозирования временных рядов является модель авторегрессионного интегрированного скользящего среднего — ARIMA. Эта модель, разработанная Боксом и Дженкинсом в 1976 году — проверенный, признанный многими экспертами метод, использующийся на протяжении многих лет.  

ARIMA — это класс моделей прогнозирования временных рядов, а название является аббревиатурой от AutoRegressive Integrated Moving 
Average. Основой ARIMA является математическая модель, которая представляет значения временного ряда, используя его прошлые значения. Эта модель основана на двух основных характеристиках: прошлые ценности и ошибки. Общий вид модели ARIMA для стационарного временного ряда задается формулой:   
![image](https://user-images.githubusercontent.com/99638036/227561554-2a2a22ff-08be-4b64-b882-5bd6b222f7ab.png)  

Для завершения описания модели ARIMA, стоит поговорить о ее преимуществах и недостатках.  

В качестве главного преимущества можно выделить то, что модель имеет четкое математическое обоснование. Это делает ее одной из наиболее научно обоснованных моделей из всего множества моделей прогнозирования тенденций во временных рядах.  

Еще одним преимуществом является формализованная и наиболее подробно разработанная методика, следуя которой можно подобрать модель, наиболее подходящую к каждому конкретному временному ряду. Формальная процедура проверки модели на адекватность достаточно проста, а разработанные методики по автоматическому подбору наилучшей ARIMA и вовсе значительно облегчает работу прогнозиста.  

Кроме того, точечные и интервальные прогнозы следуют из самой модели и не требуют отдельного оценивания.  

Один из явных недостатков моделей заключается в требовании к рядам данных: для построения адекватной модели ARIMA требуется не менее 40 наблюдений, что на практике не всегда возможно.
Вторым серьезным недостатком является неадаптивность моделей авторегрессии: при получении новых данных модель нужно периодически переоценивать, а иногда — переидентифицировать.
Третий недостаток заключается в том, что построение удовлетворительной модели ARIMA требует больших затрат ресурсов и времени. Само же построение модели требует большого опыта со стороны прогнозиста.
### FbProphet
Помимо ARIMA и некоторых других моделей, таких как экспоненциальное сглаживание, в кольце прогнозирования появились новые претенденты, из-за увеличения интереса в области науки о данных т. д., наблюдаемого в последние годы.  
Одним из этих новых претендентов является Prophet, модель временных рядов, разработанная мировой корпорацией Facebook. Компания использует эту модель в своих процессах прогнозирования. Также стоит сказать, что Prophet выпущена для общественности бесплатно, поскольку это один из проектов с открытым исходным кодом.   

Prophet — это процедура прогнозирования данных временных рядов на основе аддитивной модели, в которой нелинейные тренды соответствуют годовой, еженедельной и ежедневной сезонности, а также праздничным эффектам. Он лучше всего работает с временными рядами, которые имеют сильные сезонные эффекты и несколько сезонов исторических данных. Prophet устойчив к отсутствующим данным и сдвигам в тренде и обычно хорошо справляется с выбросами. Данная модель состоит из четырех компонентов и описывается формулой для расчета мультипликативной модели.  

Prophet не требует больших предварительных знаний или опыта прогнозирования данных временных рядов, поскольку он автоматически находит сезонные тренды по данным и предлагает набор «простых для понимания» параметров. Это позволяет людям, не связанным со статистикой и анализом данных, использовать данную модель и получать достаточно хорошие результаты.   

После рассмотрения основных определений и параметров модели Prophet стоит поговорить о ее преимуществах и недостатках.  

Prophet специально разработан для прогнозирования бизнес-временных рядов. Он дает очень хорошие результаты для данных о запасах, но он может эффектно потерпеть неудачу с наборами данных временных рядов из других областей. В частности, это справедливо для временных рядов, где понятие календарной даты неприменимо и мы не можем изучить какие-либо сезонные закономерности.   

Преимущество Prophet заключается в том, что он требует меньшей настройки гиперпараметров, поскольку он специально разработан для обнаружения закономерностей в бизнес-временных рядах. Одно ключевое различие между ARIMA и Prophet заключается в том, что модель Prophet учитывает «точки изменения» или конкретные сдвиги тренда во временном ряду. Хотя технически это возможно сделать с помощью ARIMA в R, для этого требуется использовать отдельный пакет под названием AEDForecasting.

Далее на примере наборов данных рассмотрим практическое применение данных двух моделей. Для наиболее полного сравнения мы возьмем сезонный и несезонный временной ряд. Это поможет нам увидеть, насколько хороши ARIMA и Prophet для разных наборов данных. 

## Практическая часть
Для того, чтобы показать отличия ARIMA и FBPROPHET на практике будем использовать два датасета — сезонный и несезонный. Рассматривая данные виды наборов данных, мы сможем с разных сторон посмотреть на модели и определить, какая из моделей лучшим образом работает с сезонными и несезонными данными.     

В качестве сезонных данных мы будем использовать данные международного аэропорта Сан-Франциско о ежемесячной статистике пассажиропотока по авиакомпаниям. Рассматривая несезонные данные, будем использовать информацию о числе зарегистрированных родившихся в Российской Федерации с 2008 по 2016 год.  

Прогнозирование временного ряда в данной курсовой работе будет выполняться в RStudio — свободной среде разработки программного обеспечения с открытым исходным кодом для языка программирования R, который предназначен для статистической обработки данных и работы с графикой.  

Начнем рассматривать сезонные данные. Для этого импортируем файл Air_Traffic_Passenger_Statistics.csv в рабочую область RStudio. Импортированный набор данных представлен на Рисунке:  

![image](https://user-images.githubusercontent.com/99638036/227582267-9609d5f2-f32c-48a5-8c23-ba6c3e698987.png)  
В качестве исследуемых данных на вход подаётся отчет международного аэропорта Сан-Франциско о ежемесячной статистике пассажиропотока по авиакомпаниям [2.19]. Набор данных включает в себя большое количество полей, описывающих каждый зарегистрированный в аэропорте рейс. 
Но для формирования временного ряда мы будем использовать только данные о рейсах авиакомпании KLM Royal Dutch Airlines в аэропорту Сан-Франциско с мая 2005 года по март 2016 года. 
С этой целью нам необходимо произвести предобработку данного набора. Для этого выделим с помощью фильтров интересующие нас данные и удалим ненужные столбцы, оставив в таблице данные только о дате рейса и количестве пассажиров. Обработанный набор данных представлен на Рисунке:  
![image](https://user-images.githubusercontent.com/99638036/227582562-602f14d4-b358-4425-a4a1-46a573646f68.png)  
Далее, используя преобразованный ранее фрейм данных, создадим временной ряд и построим его график:  
![image](https://user-images.githubusercontent.com/99638036/227582664-944e0ab1-11fe-4a84-888f-9e38950920f4.png)
По построенному графику исследуем временной ряд на стационарность. Мы можем видеть, что временной ряд демонстрирует зигзагообразный паттерн с практически нулевым изменением общего тренда с течением времени.
Однако формально это можно проверить с помощью теста Дики-Фуллера. Нулевая гипотеза заключается в том, что в ряду присутствует единичный корень (нестационарность), а альтернативной гипотезой является стационарность тренда.
При выполнении теста для ряда получается значение p, равное 0,01, что означает, что нулевая гипотеза отклоняется при уровне значимости 5%, что указывает на наличие стационарности в ряду. Результат теста представлен на Рисунке:  
![image](https://user-images.githubusercontent.com/99638036/227582839-e3b04638-8559-4020-94bc-328c112eb5f0.png)  
Знать о наличии или отсутствии стационарности в ряде нам необходимо, потому что если среднее значение, дисперсия и автокорреляция ряда не являются постоянными с течением времени, то это значительно затрудняет использование моделей прогнозирования для составления прогнозов.
Однако, как мы отмечали выше, параметр d в модели ARIMA обозначает количество изменений, необходимых для того, чтобы сделать ряд стационарным. При использовании функции auto.arima в R значения p, d и q выбираются автоматически.
Параметр p в ARIMA учитывает количество членов авторегрессии в модели, что позволяет модели обрабатывать автокорреляцию.
На Рисунке представлен график ACF (автокорреляционной функции) для временного ряда:    
![image](https://user-images.githubusercontent.com/99638036/227583067-8630ad62-af30-4097-a5bb-a262ca3258a0.png)  
Мы видим, что автокорреляции сохраняются в течение двух месяцев после нулевого лага, при этом положительные и отрицательные корреляции сохраняются в течение 6-месячного и 12-месячного периодов. В этом случае лаги являются месячными — следовательно, 6-месячный период указывается как 0,5, в то время как 12-месячный период указывается как 1,0.
Функция частичной автокорреляции стремится устранить косвенные корреляции, которые являются результатом присущих линейных функций, существующих между каждым наблюдением.
Вот график частичной автокорреляции для ряда:  
![image](https://user-images.githubusercontent.com/99638036/227583160-a630884b-3cfb-487f-ae43-9da80b920ea9.png)  
Мы видим, что функция частичной автокорреляции все еще показывает корреляции (хотя и отрицательные), сохраняющиеся через два месяца после нулевой задержки. Следовательно, модель ARIMA необходимо будет настроить таким образом, чтобы учитывать правильное количество членов авторегрессии.
Ниже, на Рисунке, приведен общий обзор компонентов тренда временного ряда:  
![image](https://user-images.githubusercontent.com/99638036/227583226-b6b238cf-1bd8-41ca-aa77-4e99a2d1965c.png)  
Если посмотреть на ряд, то значительная сезонность наблюдается примерно каждые шесть-восемь месяцев. Имея это в виду, модель ARIMA должна будет учитывать такую сезонность в своих прогнозах.
В данной курсовой работе мы будем выполнять моделирование с помощью функции auto.arima.
Учитывая визуальную индикацию автокорреляции, а также сезонности, auto.arima автоматически создает множества моделей ARIMA с различными координатами p, d и q — затем выбирается лучшая модель на основе модели с наименьшим BIC (байесовский информационный критерий).
С помощью функции ts() мы создаем временной ряд из данных. Этого требует модель ARIMA. И вызываем функцию auto.arima. Она находит наилучшую конфигурацию модели, представленную на Рисунке:  
![image](https://user-images.githubusercontent.com/99638036/227583309-d81bc0c0-9797-48a1-8026-54d84804ef0b.png)  
Далее с помощью встроенной функции forecast модель выполняет прогнозирование временного ряда на основании данных для обучения и вычисленной наилучшей конфигурации. Результат представлен на Рисунке:  
![image](https://user-images.githubusercontent.com/99638036/227583393-a38d5035-fd6d-4694-9ade-8d9c7291353f.png)    
Теперь мы можем сравнить значения, полученные с помощью модели ARIMA, с обучающими данными с помощью метрики MAPE, которая рассчитывает среднюю абсолютную ошибку в процентах. Для нашего прогноза данное значение получилось достаточно большим (0.3762516), из этого мы можем сделать вывод, что модель имеет не очень хороший результат прогноза.
Следующим этапом рассмотрим модель FBPROPHET для того же набора данных. Для использования данной модели нужно импортировать библиотеку prophet и переименовать столбцы набора данных для обучения. Библиотека prophet требует, чтобы столбцы носили имена ds и y. 
Как было описано ранее, Prophet работает с использованием аддитивной модели, в соответствии с которой нелинейные тренды в ряду соответствуют соответствующей сезонности (будь то ежедневная, еженедельная или годовая).
В этом конкретном наборе данных сдвиг в тенденции произошел после 2009 года, когда мы увидели изменение общей тенденции роста спроса на пассажирские перевозки:  
![image](https://user-images.githubusercontent.com/99638036/227583537-f82c328d-d9d0-430a-9977-deb45ab1a770.png)  
Далее мы воспользуемся функцией prophet из импортированного пакета. 
К набору данных была применена стандартная модель Prophet, без каких-либо ручных спецификаций сезонности. А затем методом проб и ошибок было показано, что три точки изменения минимизируют MAPE и, следовательно, были определены как соответствующее количество точек изменения в модели:  
![image](https://user-images.githubusercontent.com/99638036/227583637-2d2a0a7c-6765-4fbb-8433-ed741c644430.png)
Далее с помощью функции plot() построим график, основанный на обучающих значениях и предсказанных. График представлен на Рисунке 2.12. Черными точками обозначены точки из обучающего набора данных. Синяя линия — линия прогнозируемых значений, а голубая область — размах, где может находиться значение [2.4].  
![image](https://user-images.githubusercontent.com/99638036/227583726-279d5c6a-3268-40d0-84e3-5aaddbcb1db2.png)  
Также у пакета prophet есть функция prophet_plot_components(). С помощью нее можно посмотреть ежедневные, еженедельные и иные предсказания. На Рисунке 2.13 представлен результат выполнения этой функции.
 ![image](https://user-images.githubusercontent.com/99638036/227583909-2d975fd5-0514-4ed3-94a8-22d909f70f56.png)

Рисунок 2.13 — Недельное и годовое предсказание
Теперь можно оценить, насколько точен сделанный прогноз. Для этого снова воспользуемся метрикой MAPE. Для нашего прогноза данное значение получилось достаточно малым (0.09375141), из этого мы можем сделать вывод, что модель имеет хороший результат прогноза. 
 Исходя из полученных MAPE, мы можем сделать вывод, что для сезонных данных в данной выборке лучше использовать модель FBPROPHET, так как значение MAPE для данной модели (0.09375141) меньше, чем значение для ARIMA (0.3762516). Реализация прогнозирования количества пассажиров с помощью моделей FBPROPHET и ARIMA представлена в Приложении А в Листинге А.1.
Теперь аналогичным образом рассмотрим второй датасет. В нем наблюдается несезонная зависимость, в связи с тем что он хранит данные о числе зарегистрированных родившихся в Российской Федерации с 2006 по 2015 год.
Импортируем набор данных и посмотрим на его содержание. Оно представлено на Рисунке 2.14.
 ![image](https://user-images.githubusercontent.com/99638036/227583939-98fa5b9a-41aa-4b1e-af74-18d3dbe0397f.png)

Рисунок 2.14 — Фрагмент набора данных несезонного фрейма
Выполним тест Дикки-Фуллера, чтобы убедиться, что ряд является стационарным. Результат тестирования представлен на Рисунке 2.15. 
 ![image](https://user-images.githubusercontent.com/99638036/227583961-c527f898-2563-4603-af19-9753873acc8a.png)

Рисунок 2.15 — Результат теста Дикки-Фуллера
Исходя из полученного значения p-value (0.01), мы можем сделать вывод о том, что наш ряд стационарен, и приступить к его анализу.
Так как исходный набор данных уже обработан, то мы можем приступить сразу к прогнозированию.
Выполняя аналогичные с первым датасетом действия, находим наилучшую конфигурацию модели, представленную на Рисунке 2.16.
.  ![image](https://user-images.githubusercontent.com/99638036/227584011-d17c6d74-ed90-4d39-b6b8-9abfc39bc222.png)

Рисунок 2.16 — Наилучшая конфигурация модели ARIMA
Также с помощью встроенной функции forecast выполняем прогнозирование временного ряда на основании полученной наилучшей конфигурации. Результат представлен на Рисунке 2.17
 ![image](https://user-images.githubusercontent.com/99638036/227584051-d06ca10c-6553-445f-8d29-60fb18643ad2.png)

Рисунок 2.17 — График с предсказанными значениями
Сравниваем значения, полученные с помощью модели ARIMA, с обучающими данными с помощью метрики MAPE. Для нашего прогноза данное значение получилось достаточно малым (0.0475361), из этого мы можем сделать вывод, что модель имеет хороший результат прогноза. 
Следующим этапом снова рассмотрим модель FBPROPHET для нашего второго набора данных. 
Воспользуемся функцией prophet из импортированного пакета и с помощью функции plot() построим график, основанный на обучающих предсказанных. значениях. График представлен на Рисунке 2.18. 
 ![image](https://user-images.githubusercontent.com/99638036/227584106-6ce03404-e36b-4c8b-af34-e91e8c51bb8c.png)

Рисунок 2.18 — График с предсказанными значениями
Снова сравним значения, полученные на этом наборе данных с помощью модели FBPROPHET, с обучающими данными с помощью метрики MAPE. Для нашего прогноза данное значение получилось (0.0599306), из этого мы можем сделать вывод, что модель имеет достаточно хороший результат прогноза, но, как мы можем видеть, чуть хуже, чем результат модели ARIMA(0.0475361). 
Это говорит о том, что в данном случае, модель ARIMA показала лучшие результаты, нежели модель FBPROPHET. Реализация прогнозирования рождаемости в Российской Федерации с помощью моделей FBPROPHET и ARIMA представлена в Приложении А в Листинге А.2.
Таким образом, исходя из полученных значений, мы можем сделать вывод, что в данной конкретной ситуации модель FBPROPHET лучше прогнозирует на сезонных данные, а модель ARIMA — на несезонных. 
Однако мы не можем этого гарантировать во всех случаях. Важно понимать, что некоторые сезонные наборы данных могут лучше прогнозироваться с помощью ARIMA, а несезонные — с помощью FBPROPHET. Так как в прогнозирование очень много зависит от поставленной задачи и данных. 

### Листинг А.1 — прогнозирование пассажиропотока аэропорта с помощью моделей ARIMA и FBPROPHET
```
#Подключение библиотек
library("xts")
library(tseries)
library(fpp2)
library(Metrics)
library(prophet)
library(lubridate)
library(MLmetrics)
#Импорт данных
Passengernumbers <-read.csv("C://Users//bikaf//Desktop//KR//passengernumbers.csv", header = TRUE, sep = ';')
ds1 <- passengernumbers$Activity.Period
ds <- strptime(ds1, format = "%d.%m.%Y")
y <- passengernumbers$Passenger.Count
data <- data.frame(ds,y) 
#Создание временного ряда
passengernumbers_ts <- ts(data$y, ds,frequency = 12)
plot(passengernumbers_ts, xlab = "Time", ylab = "Passenger Numbers", main = "Passenger numbers")
#Тест Дики — Фуллера
adf.test(passengernumbers_ts)
#Дополнительны ислледования временного ряда
acf(passengernumbers_ts, lag.max = 20, plot = TRUE)
pacf(passengernumbers_ts,lag.max = 20, plot = TRUE)
components <- decompose(passengernumbers_ts)
plot(components)
#Модель ARIMA
fitpassengers<-auto.arima(passengernumbers_ts, trace=TRUE, test="kpss", ic="bic")
plot.ts(fitpassengers$residuals)
Forecasted_Passenger_Numbers <- forecast(fitpassengers)
autoplot(Forecasted_Passenger_Numbers)
summary(fitpassengers)
fv <- as.numeric(Forecasted_Passenger_Numbers$mean)
passengernumbers[,-1]
passengernumbers <- unlist(passengernumbers)
passengernumbers <- as.numeric(passengernumbers)
passengernumbers <- passengernumbers[!is.na(passengernumbers)]
MAPE(fv, passengernumbers)
#Модель FBPROPHET
F1 <- prophet(data, weekly.seasonality = TRUE, n.changepoints = 3)
forecast <- make_future_dataframe(F1, periods = 12)
predict_p <- predict(F1,forecast)
plot(F1,predict_p)
prophet_plot_components(F1, predict_p)
datap <- predict_p[1:129,]
rmse(data$y, datap$yhat)
MAPE(data$y, datap$yhat)
```

### Листинг А.2 — прогнозирование числа зарегистрированных родившихся в РФ с помощью моделей ARIMA и FBPROPHET
```
#Подключение библиотек
library("xts")
library(tseries)
library(fpp2)
library(Metrics)
library(prophet)
library(lubridate)
library(MLmetrics)
#Импорт данных
birth_rate <- read.csv("C://Users//bikaf//Desktop//KR//birth_rate.csv", header = TRUE, sep = ';')
ds1 <- birth_rate$Date
ds <- strptime(ds1, format = "%d.%m.%Y")
y <- birth_rate$Count
data <- data.frame(ds,y) 
#Создание временного ряда
birth_rate_ts <- ts(data$y, ds,frequency = 12)
plot(birth_rate_ts, xlab = "Time", ylab = "Passenger Numbers", main = "Passenger numbers")
#Тест Дики — Фуллера
adf.test(birth_rate_ts)
#Дополнительны ислледования временного ряда
acf(birth_rate_ts, lag.max = 20, plot = TRUE)
pacf(birth_rate_ts,lag.max = 20, plot = TRUE)
components <- decompose(birth_rate_ts)
plot(components)
#Модель ARIMA
fitbirth_rate<-auto.arima(birth_rate_ts, trace=TRUE, test="kpss", ic="bic")
plot.ts(fitbirth_rate$residuals)
Forecasted_birth_rate <- forecast(fitbirth_rate)
autoplot(Forecasted_birth_rate)
summary(fitbirth_rate)
fv <- as.numeric(Forecasted_birth_rate$mean)
birth_rate[,-1]
birth_rate <- unlist(birth_rate)
birth_rate <- as.numeric(birth_rate)
birth_rate <- birth_rate[!is.na(birth_rate)]
MAPE(fv, birth_rate)
#Модель FBPROPHET
F1 <- prophet(data)
forecast <- make_future_dataframe(F1, periods = 12)
predict_p <- predict(F1,forecast)
plot(F1,predict_p)
prophet_plot_components(F1, predict_p)
datap <- predict_p[1:120,]
rmse(data$y, datap$yhat)
MAPE(data$y, datap$yhat)

```


















